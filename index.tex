%
% FH Technikum Wien
% !TEX encoding = UTF-8 Unicode
%
% Erstellung von Master- und Bachelorarbeiten an der FH Technikum Wien mit Hilfe von LaTeX und der Klasse TWBOOK
%
% Um ein eigenes Dokument zu erstellen, müssen Sie folgendes ergänzen:
% 1) Mit \documentclass[..] einstellen: Master- oder Bachelorarbeit, Studiengang und Sprache
% 2) Mit \newcommand{\FHTWCitationType}.. Zitierstandard festlegen (wird in der Regel vom Studiengang vorgegeben - bitte erfragen)
% 3) Deckblatt, Kurzfassung, etc. ausfüllen
% 4) und die Arbeit schreiben (die verwendeten Literaturquellen in Literatur.bib eintragen)
%
% Getestet mit TeXstudio mit Zeichenkodierung ISO-8859-1 (=ansinew/latin1) und MikTex unter Windows
% Zu beachten ist, dass die Kodierung der Datei mit der Kodierung des paketes inputenc zusammen passt!
% Die Kodierung der Datei twbook.cls MUSS ANSI betragen!
% Bei der Verwendung von UTF8 muss dnicht nur die Kodierung des Dokuments auf UTF8 gestellt sein, sondern auch die des BibTex-Files!
%
% Bugreports und Feedback bitte per E-Mail an latex@technikum-wien.at
%
% Versionen
% *) V0.7: 9.1.2015, RO: Modeline angepasst und verschoben
% *) V0.6: 10.10.2014, RO: Weitere Anpassung an die UK
% *) V0.5: 8.8.2014, WK: Literaturquellen überarbeitet und angepasst
% *) V0.4: 4.8.2014, WK: Initalversion in SVN eingespielt
%
\documentclass[MSE,Master,english]{twbook}%\documentclass[Bachelor,BMR,ngerman]{twbook}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{csquotes}

\newboolean{showImages}
\setboolean{showImages}{true}

\newboolean{showListings} 
\setboolean{showListings}{true}

\newboolean{showTables}
\setboolean{showTables}{true} 

\newboolean{showAppliedMethodsCustomNginxConfSection}
\setboolean{showAppliedMethodsCustomNginxConfSection}{true}

\newboolean{showAppliedMethodsLoadRemoteSettingsSection}
\setboolean{showAppliedMethodsLoadRemoteSettingsSection}{true}

\newboolean{showAppliedMethodsSecondaryEntrypoints}
\setboolean{showAppliedMethodsSecondaryEntrypoints}{true}

\newboolean{showAppliedMethodsTestingQueryReduction}
\setboolean{showAppliedMethodsTestingQueryReduction}{true}

\newboolean{showResultsChapter}
\setboolean{showResultsChapter}{true}

\newboolean{showDiscussionChapter}
\setboolean{showDiscussionChapter}{true}

\newboolean{showConclusionChapter}
\setboolean{showConclusionChapter}{true}

\newboolean{showFutureWorkChapter}
\setboolean{showFutureWorkChapter}{true}

%
% Hier biblatex & Biber konfigurieren; Vergessen Sie nicht, dass Sie biber verwenden müssen um eine Bibliothek zu erzeugen
%
\usepackage[backend=biber, style=numeric]{biblatex}
\usepackage{pgfplots} 
\addbibresource{literature.bib}

%
% Bei Bedarf bitte hier die Syntax-Highlightings anpassen
%
\usepackage{minted}
\makeatletter
% Setzen der Bezeichnungen für das Quellcodeverzeichnis/Abkürzungsverzeichnis in Abhängigkeit von der eingestellten Sprache
\providecommand\listacroname{}
\@ifclasswith{twbook}{english}
{%
    \renewcommand\listoflistingscaption{List of Source Codes}
    \renewcommand\listacroname{List of Abbreviations}
}{%
    \renewcommand\listoflistingscaption{Quellcodeverzeichnis}
    \renewcommand\listacroname{Abkürzungsverzeichnis}
}
\makeatother

% Die nachfolgenden Pakete stellen sonst nicht benötigte Features zur Verfügung
\usepackage{blindtext}

%
% Einträge für Deckblatt, Kurzfassung, etc.
%
\title{Can GraphQL bring a performance \\ improvement in \\ micro-frontend architectures?}
\author{Florian Mold, BSc}
\studentnumber{11776836}
%\author{Titel Vorname Name, Titel\and{}Titel Vorname Name, Titel}
%\studentnumber{XXXXXXXXXXXXXXX\and{}XXXXXXXXXXXXXXX}
\supervisor{David Leitner, MSc}
%\supervisor[Begutachter]{Titel Vorname Name, Titel}
%\supervisor[Begutachterin]{Titel Vorname Name, Titel}
\secondsupervisor{Gehard Apfelthaler}
%\secondsupervisor[Begutachter]{Titel Vorname Name, Titel}
%\secondsupervisor[Begutachterinnen]{Titel Vorname Name, Titel}
\place{Vienna}
\kurzfassung{
  Diese Thesis zielt darauf ab zu untersuchen, ob GraphQL eine Performanceverbesserung in Micro-Frontends bringen kann. Hierzu wird ein altes, monolithisches Legacy-System in mehrere Micro-Frontends aufgeteilt. Die Legacy-Anwendung wird entsprechend von Bounded Contexts aufgeteilt. Viele Frontend-Anwendungen, welche mit REST-APIs kommunizieren, haben das Problem des Over-Fetching und Over-Requesting von Daten vom Backend. Kurz gesagt werden viele Felder unnötigerweise abgefragt, was zu verlängerten Wartezeiten führt. Eine GraphQL-API wird als Backend for Frontend für die Micro-Frontends verwendet, um die Probleme des Over-Fetching und Over-Requesting anzugehen. Das BFF bildet ein Gateway zum Microservice-Cluster und ruft die Daten der Services ab und aggregiert sie. GraphQL bietet Micro-Frontends sehr anpassbare Queries, welche genau die benötigten Daten laden. Viele GraphQL Clients bieten eine In-Memory Caching-Schicht, welche die Ergebnisse der Abfragen speichert. Die gecachten Daten können verwendet werden, um Daten für eine GraphQL-Abfrage zurückzugeben, welche bereits ausgeführt wurde. Die Verwendung des Micro-Frontend Architekturstils bedeutet, dass jede Anwendung ihre eigene Instanz des Caches hat. Dieser Ansatz führt zu vielen unnötigen Anfragen, die der Cache direkt beantworten könnte. Eine Maßnahme zur Verbesserung der Leistung is die Implementierung einer gemeinsam genutzten Caching-Schicht zwischen allen Micro-Frontends. Ein Mechanismus zur Entfernung von Feldern aus GraphQL-Abfragen mit vorhandenen Daten aus dem Cache kann weitere Performanceverbesserungen bringen. Micro-Frontends folgen den Prinzipien von Microservices: Sie sollen unabhängig entwickelt und bereitgestellt werden. Die Architektur des Prototyps soll in Zukunft dazu verwendet werden, das alte System des Unternehmens zu ersetzen. Daher ist es wichtig die Architektur so technologieagnostisch wie möglich zu gestalten. Die gemeinsame genutzte Caching-Schicht und der Reduktionsmechanismus sollte unabhängig von der eingesetzten Technologie funktionieren.

  \bigskip

  \noindent Die Architektur wird dann hinsichtlich ihrer Leistung in Bezug auf die Größe der Anfrage und die Größe der Antwort analysiert. Die Ergebnisse zeigen mehrere interessante Erkenntnisse. Die Verwendung einer gemeinsamen Caching-Schicht verbessert die Leistung drastisch im Vergleich zum naiven Ansatz, bei dem jedes Micro-Frontend seinen eigenen Cache verwendet. Die Reduzierung der Anfragen bringt in diesem Szenario keine signifikante Verbesserung gegenüber der massiven Verbesserung durch die gemeinsame Caching-Schicht.
}

\schlagworte{GraphQL, Micro-frontend, Caching, Backend For Frontend, Apollo Client, Angular React, Webpack}

\outline{
  This thesis aims to evaluate whether GraphQL can bring a performance boost in micro-frontend architectures. For this purpose, an old monolithic legacy system is divided into multiple micro-frontends, each responsible for its domain. The legacy application is sliced according to bounded contexts. Many frontend applications that communicate with REST API's face the problem of over-fetching and over-requesting data from a backend. In a nutshell, many fields are unnecessarily fetched, leading to a performance penalty, and too many network requests are made to aggregate the data. A GraphQL API is used as a Backend For Frontend for the micro-frontends to tackle the problems of over-fetching and over-fetching. The BFF forms a gateway to the microservice cluster and fetches and aggregates the data of the services. GraphQL offers micro-frontends highly customizable queries that fetch precisely the data needed for the requirement. Many GraphQL frontend clients offer an in-memory caching layer that stores the results of the queries. The cached data can be used to return data for a GraphQL query that has already been executed before. Adapting the micro-frontend pattern means that each application has its instance of the cache. This approach leads to many unnecessary requests that the cache could serve directly. One action to improve the performance is implementing a shared caching layer between all micro-frontends. Another step to boost the performance is implementing a mechanism to reduce GraphQL queries with existing data from the cache. Micro-frontends follow microservices' principles: they should be independently developed and deployed. The prototype's architecture should be used to replace the company's legacy system in the future; therefore, it is essential to make the architecture as technology agnostic as possible. The shared caching layer and reduction mechanism should work regardless of the technology used.

  \bigskip

  \noindent The architecture is then analyzed concerning its performance regarding request size and response size. The outcomes show several exciting findings. Using a shared caching layer dramatically improves the performance, in comparison to the naive approach where each micro-frontend uses its separate cache. The query reduction does not bring a significant improvement in this scenario, over the massive improvement of the shared caching layer.
}

\keywords{GraphQL, Micro-frontend, Caching, Backend For Frontend, Apollo Client, Angular React, Webpack}

\acknowledgements{

I would like to express my heartfelt gratitude to AGnet's CEO Gerhard Apftelthaler for providing me with the opportunity to pursue this Master's degree and for supporting me throughout the process. He provided me with complete freedom to develop the prototypical system and was always available to assist with any questions I had. His dedication and support were exceptional, and I cannot thank him enough for the invaluable guidance he provided.

\bigskip

\noindent I would also like to extend my sincere thanks to my supervisor, David Leitner, for his invaluable guidance and support during my thesis. His lectures were instrumental in developing my interest in this field, and I was able to apply much of the content from his classes to this project. His patience, expertise, and encouragement helped me to navigate the challenges of this research and to develop my skills and achieve my goals.

\bigskip

\noindent Finally, I would like to thank my family and friends for their unwavering support and encouragement throughout my academic journey. Their love and encouragement were instrumental in helping me to achieve this significant milestone in my life.
} 

\begin{document}

\maketitle


\input{chapters/introduction.tex}

\input{chapters/background.tex}

\input{chapters/applied-methods.tex}

\ifshowResultsChapter
  \input{chapters/results.tex}
\fi

\ifshowDiscussionChapter
  \input{chapters/discussion.tex}
\fi

\ifshowConclusionChapter
  \input{chapters/conclusion.tex}
\fi

\ifshowFutureWorkChapter
  \input{chapters/future-work.tex}
\fi


%
% Hier beginnen die Verzeichnisse.
%
\clearpage
\printbibliography
\clearpage

% Das Abbildungsverzeichnis
\listoffigures
\clearpage

% Das Tabellenverzeichnis
\listoftables
\clearpage

% Das Quellcodeverzeichnis
\listoflistings
\clearpage

\phantomsection
\addcontentsline{toc}{chapter}{\listacroname}

\chapter*{\listacroname}
\begin{acronym}[XXXXX]
  \acro{HTTP}{Hypertext Transfer Protocol}
  \acro{URL}{Uniform Resource Locator}
  \acro{API}{Application Programming Interface}
  \acro{SPA}{Single-Page-Application}
  \acro{BFF}{Backend For Frontend}
  \acro{REST}{Representational State Transfer}
  \acro{IP}{Internet-Procotol}
  \acro{HTML}{Hypertext Markup Language}
  \acro{IDE}{Integrated development environment}
  \acro{JSON}{JavaScript Object Notation}
  \acro{SQL}{Structured Query Language}
  \acro{gRPC}{gRPC Remote Procedure Calls}
  \acro{JS}{JavaScript}
  \acro{TS}{TypeScript}
  \acro{DI}{Dependency Injection}
  \acro{UI}{User Interface}
  \acro{ID}{Identifier}
  \acro{UML}{Unified Modeling Language}
\end{acronym}

%
% Hier beginnt der Anhang.
%
\clearpage
\appendix
\chapter{Appendix A: Source Code from GitHub}

\subsubsection{Prototype architecture Source Code:} \url{https://github.com/FlorianMold/improving-micro-frontend-architectures-with-apollo-client}

\subsubsection{Forked apollo-augmented-hooks:} \url{https://github.com/FlorianMold/improving-micro-frontend-architectures-with-apollo-client/blob/main/libs/shared/feature/graphql-augmented-operations/src/lib/augmented-query.ts}

% \clearpage
% \chapter{Anhang B}
\end{document}
