\section{GraphQL}

GraphQL was developed by Facebook and refers to itself as the query language for API's. It provides the client with the opportunity to ask exactly for the data is needed. GraphQL offers the advantage that all data can be loaded from only one URL. With the help of the types within the GraphQL schema, the technology offers an understandable description of the API for clients. \cite{misc:-:background:graphql:graphql-org} The functionality of GraphQL on the frontend can be compared to SQL for databases. The client writes its queries with the desired fields from a type.

\bigskip

\noindent The official documentation states that GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools. GraphQL is implemented in many languages and frameworks. It has a large ecosystem of libraries and tools.

\subsection{Origins and history}

GraphQL was initially developed at Facebook in 2012. In 2015 the project was made open-source and available to the public. The motivation behind the initial development of GraphQL was the limited flexibility of available API technologies like REST. Mobile devices needed only a subset of the fields that a REST endpoint offered. And the exact amount of fields can change dynamically. The static background of REST does not offer this behavior. Using REST based APIs for clients that do not need all fields would introduce the problem of Overfetching. Clients will receive more information than is actually needed. This leads to problems as mobile networks often have limited network traffic. Overfetching puts additional strain on the users data plan. \cite{misc:2015:bryon:background:graphql:graphql-query-language}

\subsection{GraphQL Characteristics}

GraphQL is based on several design principles: \cite{misc:-:background:graphql:graphql-specification}

\begin{itemize}
    \item \textbf{Hierarchical}: Queries in GraphQL are structured in a hierarchical manner, allowing the clients to specify what data they need and in what format. This approach enables efficient data retrieval and reduces network overhead.

    \item \textbf{Product-centric}: GraphQL is designed to be product-centric, rather than data-centric. This means that developers can create APIs that match the needs of specific products or features, rather than being constrained by the limitations of a pre-defined data schema.

    \item \textbf{Strong typing}: GraphQL is strongly-typed, meaning that the types of data are defined explicitly in the schema. This provides clarity and reduces ambiguity in the API design, while also enabling powerful tools for type checking and code generation.

    \item \textbf{Client-specified queries}: In GraphQL, the client specifies the structure of the query, rather than the server. This approach allows clients to retrieve only the data they need, reducing network overhead and enabling faster, more responsive applications.

    \item \textbf{Introspective}: GraphQL provides a built-in introspection system that enables clients to query the schema itself, allowing for powerful self-documentation and tooling capabilities.

    \item \textbf{Declarative}: GraphQL queries are declarative, meaning that they specify what data is needed, rather than how it should be retrieved. This approach allows the server to optimize the query execution, while also making it easier to reason about and understand the API.
\end{itemize}

\subsubsection{Advantages}

GraphQL helps reducing the network traffic between the clients and the backend they query. Research indicates that the dynamic approach to fetching data can reduce the number of fields to be fetched and therefore the bytes that are sent back and forth to the GraphQL server. \cite{inprocessdings:2019:background:graphql:migration-to-graphql}

\bigskip

\noindent Because the client specifies the required fields that should be fetched, the complexity on the backend can be reduced. The backend does not need to implement a lot of endpoints that are only used by a small subset of clients. The backend can implement a single endpoint that can be queried by all clients. \cite{book:2018:richardson:background:bff:microservices-patterns}

\bigskip

\noindent The characteristic that GraphQL can query its own schema allows service discovery potential. With the help of introspection GraphQL provides tools like GraphQL Voyager, which can be used to visualize the schema in a UML class-diagram style. Other tools like GraphiQL can be used to analyses the schema. The functionality of such tools is explained in chapter Apollo Client and Server in more detail. The alternative REST provides such functionality to some degree, but additional tooling is needed, because REST can't generate specification files.

% TODO: Link to GraphQL Voyager

\subsubsection{Disadvantages}

\noindent The advantage that GraphQL reduces complexity on the backend is a disadvantage for the client-side application. It leads to a higher complexity, when consuming GraphQL services compared to REST. With REST only an endpoint has to be queried, whereas with GraphQL the requested data has to be specified to the field level. But the introspection abilities of GraphQL allow the consumers to better understand the structure of the query and data, which mitigates the disadvantage. A study \cite{inproceedings:2020:brito:background:graphql:rest-vs-graphql} showed that the participants of the study found it easier to to consume a GraphQL Service than consuming a REST Service.

% TODO: cite

\bigskip

\noindent GraphQL shifts more responsibilities from the backend to the client, which is normally done with a gateway. API composition can shift from the server to the client. Depending on the actual use-capabilities

\bigskip

\noindent By giving the client the opportunity to specify the query, it might make the potential complexity of the query transparent to the client. With this approach it might be possible that the client specifies a query, that is not completable or takes up a lot of resources. GraphQL makes it somewhat difficult that clients remain good citizens in a distributed architecture. \cite{book:2018:richardson:background:bff:microservices-patterns}


% Section about apollo-client
\input{chapters/background/graphql/apollo-client-server}

% Section about the query reduction
\input{chapters/background/graphql/query-reduction.tex}
