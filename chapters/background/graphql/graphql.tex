\section{GraphQL}\label{section:background:graphql}

GraphQL was initially developed by Facebook and referred to itself as the query language for APIs. It allows the client to ask precisely for the data needed. GraphQL offers the advantage that all data can be fetched from only one URL. With the help of the types within the GraphQL schema, the technology offers an understandable description of the API for clients. \cite{misc:-:background:graphql:graphql-org} The functionality of GraphQL on the frontend can be compared to SQL for databases. The client writes its queries with the desired fields from a type.

\bigskip

\noindent The official documentation states that GraphQL is a query language for APIs and a runtime for fulfilling those queries with existing data. GraphQL provides a complete and understandable description of the data in the API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools. The GraphQL specification is implemented in many languages and frameworks and has an extensive library and tool ecosystem.

\subsection{Origins and history}\label{subsection:background:graphql:origins-and-history}

GraphQL was initially developed in 2012. In 2015 the project was made open-source and available to the public. The motivation behind the initial development of GraphQL was the limited flexibility of available API technologies like REST. Mobile devices needed only a subset of the fields that a REST endpoint offered. Furthermore, the exact amount of fields can change dynamically. The static background of REST does not offer this behavior. Using REST-based APIs for clients that only need some fields would introduce the problem of Overfetching. Clients will receive more information than is needed. This approach leads to problems as mobile networks often have limited network traffic. Overfetching puts additional strain on the user's data plan. \cite{misc:2015:bryon:background:graphql:graphql-query-language}

\subsection{GraphQL Characteristics}\label{subsection:background:graphql:graphql-characteristics}

GraphQL is based on several design principles: \cite{misc:-:background:graphql:graphql-specification}

\begin{itemize}
    \item \textbf{Hierarchical}: Queries in GraphQL are structured hierarchically, allowing the clients to specify what data they need and in what format. This approach enables efficient data retrieval and reduces network overhead.

    \item \textbf{Product-centric}: GraphQL is designed to be product-centric rather than data-centric. That means that developers can create APIs that match the needs of specific products or features rather than being constrained by the limitations of a pre-defined data schema.

    \item \textbf{Strong typing}: GraphQL is strongly-typed, meaning the data types are defined explicitly in the schema. The typing provides clarity and reduces ambiguity in the API design while also enabling powerful tools for type checking and code generation.

    \item \textbf{Client-specified queries}: In GraphQL, the client specifies the structure of the query rather than the server. This approach allows clients to retrieve only the needed data, reducing network overhead and enabling faster, more responsive applications.

    \item \textbf{Introspective}: GraphQL provides a built-in introspection system that enables clients to query the schema, allowing for powerful self-documentation and tooling capabilities.

    \item \textbf{Declarative}: GraphQL queries are declarative, meaning they specify what data is needed rather than how it should be retrieved. This approach allows the server to optimize the query execution and make it easier to reason about and understand the API.
\end{itemize}

\subsection{Advantages}\label{subsection:background:graphql:graphql-advantages}

GraphQL helps to reduce the network traffic between the clients and the backend they query. Research indicates that the dynamic approach to fetching data can reduce the number of fields to be fetched and, therefore, the bytes sent back and forth to the GraphQL server. \cite{inprocessdings:2019:background:graphql:migration-to-graphql}

\bigskip

\noindent Because the client specifies the required fields that should be fetched, the complexity on the backend can be reduced. The backend does not need to implement many endpoints, only used by a small subset of clients. The backend can implement a single endpoint that all clients can query. \cite{book:2018:richardson:background:bff:microservices-patterns}

\bigskip

\noindent The characteristic that GraphQL can query its schema allows service discovery potential. With the help of introspection, GraphQL provides tools like GraphQL Voyager, which can be used to visualize the schema in a UML class diagram style. Other tools like GraphiQL can be used to analyze the schema. The functionality of such tools is explained in section \ref{subsection:background:graphql:apollo-server-client} in more detail. The alternative REST provides such functionality to some degree, but additional tooling is needed because REST cannot generate specification files.

% TODO: Link to GraphQL Voyager

\subsection{Disadvantages}\label{subsection:background:graphql:graphql-disadvantages}

\noindent The advantage that GraphQL reduces complexity on the backend is a disadvantage for the client-side application. It leads to higher complexity when consuming GraphQL services compared to REST. With REST, only an endpoint has to be queried, whereas, with GraphQL, the requested data has to be specified at the field level. However, the introspection abilities of GraphQL allow consumers to understand better the query and data structure, which mitigates the disadvantage. A study \cite{inproceedings:2020:brito:background:graphql:rest-vs-graphql} showed that the study participants found it easier to consume a GraphQL Service than a REST Service.

% TODO: cite

\bigskip

\noindent GraphQL shifts responsibilities from the backend to the client, generally done with a gateway. API composition can shift from the server to the client. Depending on the actual use-capabilities

\bigskip

\noindent Allowing the client to specify the query might make the potential complexity of the query transparent to the client. With this approach, it might be possible that the client specifies a query that needs to be completed with long response times or takes up many resources. GraphQL makes it difficult for clients to remain good citizens in a distributed architecture. \cite{book:2018:richardson:background:bff:microservices-patterns}


% Section about apollo-client
\input{chapters/background/graphql/apollo-client-server}

% Section about the query reduction
\input{chapters/background/graphql/query-reduction.tex}
