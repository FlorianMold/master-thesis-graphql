\section{Software Monoliths}

A monolithic architecture is characterized that there is only one single codebase. Many developers, no matter from which team are working on the same application. This approach to development was the standard for a very long time and is well supported by various development tools.

\subsubsection{Disadvantages}

With a growing code base, monolithic architectures come with increased complexity. Each new feature adds another level of complexity, which leads to reduced development performance. Developing a new feature might be a very long process, due to the existing entry hurdle. The sheer size of the code base makes it difficult to understand, because program comprehension is a very important factor for the maintenance of software. Therefore, developers might create side effects when fixing a bug. The time for developing a new feature increases drastically and the internal architecture can become difficult to understand and maintain as well.

Another problem is, that multiple teams might work on the same chunks of code. It might happen that two different developers need to make a change to code in a shared library. It might happen that a developer changes code inside a module, which the developer does not have enough knowledge about the module. The change is also not coordinated with other software engineers. This might lead to unexpected behavior in the code of the other developer. The circumstance is also \textit{confused lines of ownership}, which are sources of failures for a software system.

This might also lead \dots

With a monolithic approach, the use of different technologies is not possible anymore. The technology stack is restricted to the entire life of the monolith. The introduction of a different programming language or a different framework is hardly possible and often leads to a complete rewrite of an application. \cite{book:2018:richardson:background:bff:microservices-patterns}

The problem with technology is that it always becomes deprecated at one point in time. Applications based on such frameworks have to migrated to a different technology. A simple rewrite in another technology is not possible most times.

\subsubsection{Legacy}

The term legacy should not be a synonym for legacy systems. The advantages of 