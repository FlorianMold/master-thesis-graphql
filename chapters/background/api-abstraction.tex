\section{API Abstraction}\label{section:background:api-abstraction}

Every microservice provides its functionality to consumers with \acp{API}. Nevertheless, it is not advisable that clients directly communicate with microservice \acp{API}. Microservice offer fine-grained interfaces which were made especially for the communication between microservices. Therefore, the client usually has to make multiple requests to fetch and aggregate the data to display a view inside the application. \cite[69]{book:2021:newman:background:bff:micro-services} This approach leads to many requests, also known as over-requesting, which harms the user experience. \cite[254, 257]{book:2018:richardson:background:bff:microservices-patterns} Both over-requesting and over-fetching are explained in more detail in the Section \ref{subsection:background:micro-frontend:generic-vs-consumer-driven-apis}.

\bigskip

\noindent Another problem could be that a cluster of microservices uses another form of communication. For example, an asynchronous message bus or another protocol like \ac{GRPC} differs from the \ac{HTTP}. Clients usually communicate using synchronous communication, whereas microservices might use asynchronous communication. With an adapter in between, the communication will work properly. Even if communication is possible, the client needs to know many internal details about the cluster of microservices, like the \ac{IP} address. It needs to be clarified which microservice offers the data that is needed for the client. Changing the \ac{API} of a microservice would have a ripple effect on the requests on the frontend because they would have to be changed in many places. \cite[254-257]{book:2018:richardson:background:bff:microservices-patterns}

\bigskip

\noindent The clients communicate with an \ac{API} gateway or a more client-centric \ac{BFF} service to solve this problem. \ac{API} gateways present an abstraction of microservice \acp{API}, and it is the entry point to the system that is composed of multiple microservices. \cite[19-20]{book:2020:siriwardena:background:bff:microservice-security-in-action}

\bigskip

\noindent The main task of a gateway is to forward tasks to the correct microservice and compose \ac{API} for loading the needed data in one request. They might implement functionalities like authorization and authentication or transform the protocol, like converting \ac{HTTP} to \ac{GRPC}. With \ac{API} gateways, it is also easier to split a microservice into two separate services without a ripple effect to change all clients that consume that microservice. \cite[260-263]{book:2018:richardson:background:bff:microservices-patterns}

\bigskip

\noindent However, the problem with \ac{API} gateways is the ownership. Multiple teams will add their functionality to the gateway and might come into conflict. The \acp{API} are often not suited for clients' needs, and it must be avoided that client logic is put into the \ac{API} gateway. Another pattern to bypass the problems with \ac{API} gateways is the \ac{BFF} pattern. \cite[265-266]{book:2018:richardson:background:bff:microservices-patterns}

\bigskip

\noindent With this approach, each client application has its own \ac{API} gateway called \ac{BFF} service. This service is specially designed to fit the needs of the client. \cite[264-266]{book:2018:richardson:background:bff:microservices-patterns} \cite[71-7]{book:2021:newman:background:bff:micro-services} This method allows every team to develop their \ac{BFF} isolated and autonomous. Therefore a team can develop a complete vertical product from the microservice to the \ac{BFF} and, finally, the micro-frontend. \cite{book:2020:geers:background:micro-frontends:micro-frontends-in-action}
