\subsection{Communication}\label{subsection:background:micro-frontend:communication-patterns}

Micro-frontends should not have code dependencies on each other. Nevertheless, it is necessary to have communication between them. For example, if a user adds an item to a shopping cart in an e-commerce application, the product micro-frontend has to inform the shopping-cart micro-frontend which item was added. To reduce the coupling between applications and development teams, keeping the communication between micro-frontends at a minimum is recommended. Before choosing a communication pattern, it is vital to know the type of communication. If communication between micro-frontends or between the application shell and micro-frontends is needed, the communication can take place via the user interface. \cite{book:2020:geers:background:micro-frontends:micro-frontends-in-action} Other communication instruments, like the Broadcast Channel \ac{API} provided by the browser, is helpful for state management, state sharing or for transferring information to the micro-frontends. \cite{misc:-:background:micro-frontends:broadcast-channel-api} 

\bigskip

\noindent If the micro-frontends are integrated using hyperlinks, he communication can only happen via \ac{URL} parameters, because each application has a separate context. \acp{SPA} normally communicate via custom events or attribute changes of the \ac{HTML} elements. \cite[100]{book:2020:geers:background:micro-frontends:micro-frontends-in-action} \cite[315-316]{book:2019:farrell:background:micro-frontends:web-components-in-action} It can be distinguished between parent-to-fragment, fragment-to-parent or fragment-to-fragment communication, where the term fragment is equivalent to a micro-frontend and the term parent is equivalent to the application shell. \cite{book:2020:geers:background:micro-frontends:micro-frontends-in-action} Figure \ref{fig:background:micro-frontend:communication:communication-patterns} shows the three types of communication in a diagram:

\ifshowImages
\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\linewidth]{images/background/micro-frontends/communication/communication-patterns.png}
  \caption{Different forms of communication in micro-frontend architectures. (Adapted from \cite[100]{book:2020:geers:background:micro-frontends:micro-frontends-in-action})}\label{fig:background:micro-frontend:communication:communication-patterns}
\end{figure}
\fi

\noindent Parent-to-fragment communication can happen through attribute changes if custom elements are used. \cite[58-59]{book:2019:farrell:background:micro-frontends:web-components-in-action} To send data from a micro-frontend to the application shell, custom events of \ac{HTML} elements can be used. \cite[315]{book:2019:farrell:background:micro-frontends:web-components-in-action}, where a micro-frontend publishes an event, which the application shell listens to. \cite{book:2020:geers:background:micro-frontends:micro-frontends-in-action}

\bigskip

\noindent Fragment-to-fragment communication is required when two micro-frontends should communicate with each other. The changes in one micro-frontend should affect the other micro-frontend. This form of communication can be implemented in three ways: \cite[107-108]{book:2020:geers:background:micro-frontends:micro-frontends-in-action}

\begin{itemize}
  \item \textbf{Direct communication}: Direct communication is the most direct form of communication. One micro-frontend changes the attributes of the other micro-frontends \ac{HTML} elements with \ac{JS}. This approach is not recommended because it introduces tight coupling between the micro-frontends. One micro-frontends needs to have some implementation details of the other micro-frontend. This approach makes it difficult to change the implementation of one micro-frontend without breaking the communication. Moreover, this violates one characteristic of micro-frontends, which are independent and autonomous development and deployment.
  \item \textbf{Orchestration via a parent}: The application shell is responsible for communicating between micro-frontends. One micro-frontend emits an event, which is intercepted by the application shell, and the application shell forwards the event to the target micro-frontend. This approach allows the micro-frontends to be completely decoupled, but every micro-frontend must adapt to communication changes.
  \item \textbf{Event-Bus/broadcasting}: Rather than direct communication between micro-frontends or indirect communication via the application shell, where a micro-frontend could publish an event to an event bus. The other micro-frontends can subscribe to the events and react accordingly. This pattern is described as publish/subscribe mechanism, drastically reducing the tight coupling between multiple micro-frontends. No micro-frontend requires implementation details about the other micro-frontends, allowing almost perfect parallel development.
\end{itemize}
