\section{Micro-Frontend Architecture}

Micro-frontends should bring the same advantages of microservices from the backend to the frontend. Instead of creating a large frontend monolith, a micro-frontend architecture contains many small applications. The advantage is that every micro-frontend can be developed and deployed by a separate team. \cite{book:2020:geers:background:micro-frontends:micro-frontends-in-action} The difference between a monolithic frontend architecture and a micro-frontend architecture can be seen in figure \ref{fig:state-of-the-art:ui-monolith-micro-frontend}.

\ifshowImages
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/ui-monolith-micro-frontends.jpeg}
    \caption{A comparison between frontend-monoliths and micro-frontends.}\label{fig:state-of-the-art:ui-monolith-micro-frontend}
\end{figure}
\fi

\noindent Benefits gained from working with microservices on the backend are lost, when working with a monolithical frontend. With a monolithic frontend, the ability to deploy independently is lost. The entire frontend has to be deployed at once. Another problem is, that distinct operations are not really possible. If one part of the frontend is broken, there is a good chance that the entire frontend is broken. Another problem is the parallel development. The speed of development cannot be increased because it is very difficult to have multiple teams working on one frontend application. \cite{misc:2019:leitner:background:micro-frontends:micro-frontends-basics}

\bigskip

\noindent The term micro-frontend can be misleading, as can the term microservice. It has no meaning in terms of the size of the application. It can be a simple widget that only displays data, or a full-blown one-page application. Ideally, a micro frontend covers an area of the entire frontend application.

\bigskip

\noindent Micro-frontends try to apply the same principles from the microservice architecture to frontend development. Often times a microservice architecture with is developed by several teams has only one frontend application. Therefore, when adding new features a single team can be overwhelmed. Like a microservice architecture, a micro-frontend architecture focuses on developing many small frontend-applications, instead of developing a large software monolith. Each micro-frontend can be developed independently by another team. But a challenge is that the micro-frontend should appear as a single application to the user. Therefore, the different applications have to be integrated, which can be a challenge.

\bigskip

\noindent Building micro-frontends with the web allows different strategies of integrating the applications. Three different strategies exist to combine multiple micro-frontends into an app-shell. The client-side integration, the server-side integration and the combination of these two strategies. \cite[10-12]{book:2020:geers:background:micro-frontends:micro-frontends-in-action}

\subsection{Characteristics}

Micro-frontends tend to follow the same characteristics as microservices, which are described in more detail in this chapter.

\subsubsection{Autonomous}

Technically a micro-frontend is a completely independent and runnable application. The integration of the micro-frontends happens only through the frontend. The different micro-frontends are composed withing an app-shell. The application shell is a separate application that is usually the entry-point for the user to interact with all micro-frontends. The app-shell also provides the layout of the page and defines where the micro-frontends are placed. The autonomy should not go in the direction of complete isolation. But no dependencies should emerge, which could harm the autonomy. \cite{book:2020:geers:background:micro-frontends:micro-frontends-in-action}

\subsubsection{Technology Agnostic}

Just as microservices architectures, micro-frontend architectures can be technology agnostic. The current frontend development landscape offers a lot of JavaScript frameworks to choose from. The advantage of an application that consists of small independent building blocks is that parts can be rewritten with another technology more easily. \cite[14-16]{book:2020:geers:background:micro-frontends:micro-frontends-in-action} But using different technologies for different micro-frontends can lead to problems with the chosen form of integration and communication. The communication should be technology agnostic as well and should use browser native tools like Broadcast Channel API.

\bigskip

\noindent Another problem that could arise is the bundle size of modern JavaScript frameworks. If two frameworks like React and Angular need to be fetched, the total bundle size can be very large and a strain for network connections. Loading an running multiple micro-frontends is also resource intensive. Due bypass this problem and offer a standardized API, micro-frontends can be developed with the help of Web Components. With this approach, no specific framework is needed to the application. \cite{book:2020:geers:background:micro-frontends:micro-frontends-in-action}

\subsubsection{Independently Depoyable}

The autonomy of micro-frontends offer the possibility for independent deployments. A large monolithical frontend application is more complex to deploy. There is no need to have communication and coordination over multiple teams to deploy the application. Organizational dependencies have a negative impact on the time-to-market, because development teams would have to wait for the release of another team. \cite[12]{book:2020:geers:background:micro-frontends:micro-frontends-in-action}

\subsubsection{Small and Easy to Maintain}

Because micro-frontends only cover a small domain of an application, the source code is smaller and easier to understand. A smaller codebase is especially helpful for understanding the inner workings of software. Onboarding new team members is also easier, because the codebase is smaller.
Due to the easier understanding of the domain, the application can be easier rewritten with a state of the art technology, if the old one becomes deprecated. \cite{book:2020:geers:background:micro-frontends:micro-frontends-in-action}

\subsubsection{Resilience}

Micro-frontends offer the possibility to build an application by composing multiple independent small applications into a fully fledged application. Depending on the integration strategy micro-frontends are usually combined at runtime. But the network, especially for mobile devices is not always without failures. A micro-frontend architecture provides better failure isolation. One micro-frontend crashing does not have an effect on the other micro-frontends inside the application. Some parts of the application might not work, but other parts of the application are still useable. The app-shell can react to a failure and tell users that the application is not working as expected and will be available back soon. \cite[10-11]{article:2021:perltonen:background:micro-frontends:motivations-benefits-and-issues}

\subsection{Downsides of Micro-frontend architecture}

Due to the many advantages of micro-frontends there are also a downsides using this architectural approach. The independent development comes with the disadvantage of having redundancies. Each micro-frontend needs a separate build-process and also a continuous integration pipeline. And if the backend-for-frontend approach is used, every micro-frontend needs it own backend-for-frontend service. It might happen that a lot of code is duplicated. when implementing this pattern. If multiple teams use the same code and a bug is found, the wrong behavior can't be fixed in a central place. Therefore, it is important to share knowledge between the teams to avoid running in the same bad situations over and over again. But this should not lead to inter-team dependencies between the different teams.
\cite[17-18]{book:2020:geers:background:micro-frontends:micro-frontends-in-action}


\input{chapters/background/micro-frontend/integration-strategies.tex}

\input{chapters/background/micro-frontend/communication-patterns.tex}

\input{chapters/background/micro-frontend/module-federation/module-federation.tex}

\input{chapters/background/micro-frontend/overfetching-overrequesting.tex}
