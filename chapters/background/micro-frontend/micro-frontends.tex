\section{Micro-Frontend Architecture}\label{section:background:micro-frontend-architecture}

Micro-frontends should bring the same advantages of microservices to the frontend. Instead of creating a giant frontend monolith, a micro-frontend architecture contains many small applications. The advantage is that a separate team can develop and deploy every micro-frontend independently. \cite{book:2020:geers:background:micro-frontends:micro-frontends-in-action} The difference between monolithic frontend architecture and micro-frontend architecture can be seen in the Figure \ref{fig:background:micro-frontend:monolith-micro-frontend-comparison}.

\ifshowImages
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/background/micro-frontends/monolith-micro-frontends-comparison.jpg}
    \caption{A comparison between frontend-monoliths and micro-frontends.}\label{fig:background:micro-frontend:monolith-micro-frontend-comparison}
\end{figure}
\fi

\noindent Benefits gained from working with microservices are lost when working with a monolithic frontend. With a monolithic frontend, the ability to deploy independently is lost. The entire frontend has to be deployed at once. Another problem is that distinct operations are not possible. If one part of the frontend is broken, there is a good chance that the entire frontend does not work. Another problem is parallel development. The development speed cannot be increased because having multiple teams working on one frontend application is very difficult. \cite{misc:2019:leitner:background:micro-frontends:micro-frontends-basics}

\bigskip

\noindent The term micro-frontend can be misleading, as can the term microservice. It has no meaning in terms of the size of the application, and it can be a simple widget that only displays data or a full-blown single-page application. Ideally, a micro frontend covers an area of the entire frontend application.

\bigskip

\noindent Micro-frontends apply the same principles from the microservice architecture to frontend development. Often a microservice architecture developed by several teams has only one frontend monolith. Therefore, when adding new features, a single team can be overwhelmed. Like a microservice architecture, a micro-frontend architecture focuses on developing many small frontend applications instead of developing a giant software monolith. Each micro-frontend can be developed independently by another team. However, a challenge is that the micro-frontend should appear as a single application to the user. Therefore, the different applications must be integrated, which can be challenging.

\bigskip

\noindent Building micro-frontends with the web allows different strategies for integrating the applications. Three strategies exist to combine multiple micro-frontends into an application shell: client-side integration, server-side integration, and the combination of these two strategies. \cite[10-12]{book:2020:geers:background:micro-frontends:micro-frontends-in-action}

\subsection{Characteristics}\label{subsection:background:micro-frontend-characteristics}

Micro-frontends follow the same characteristics as microservices, described in more detail in this chapter.

\subsubsection{Autonomous}\label{subsubsection:background:micro-frontend-autonomous}

Technically a micro-frontend is an entirely independent and runnable application. The integration of the micro-frontends happens only through the frontend. The different micro-frontends are composed within an application shell. The application shell is a separate application that is usually the entry point for the user to interact with all micro-frontends. The application shell also provides the page layout and defines where the micro-frontends are displayed. Autonomy should not go in the direction of complete isolation. Nevertheless, no dependencies should emerge, which could harm autonomy. \cite{book:2020:geers:background:micro-frontends:micro-frontends-in-action}

\subsubsection{Technology Agnostic}\label{subsubsection:background:micro-frontend-technology-agnostic}

Just as microservice architectures, micro-frontend architectures can be technology agnostic. The current frontend development landscape offers a lot of \ac{JS} frameworks, which offer different advantages and disadvantages. The advantage of an application with small independent building blocks is that parts can be rewritten with another technology more efficiently. \cite[14-16]{book:2020:geers:background:micro-frontends:micro-frontends-in-action} However, using different technologies for different micro-frontends can lead to problems with the chosen form of integration and communication. The communication should also be technology agnostic and use browser-native tools like Broadcast Channel \ac{API}.

\bigskip

\noindent Another problem that could arise is the bundle size of modern \ac{JS} frameworks. If two frameworks like React and Angular need to be fetched, the total bundle size can be enormous and a strain on (mobile) network connections. Loading and running multiple micro-frontends is also resource intensive. Micro-frontends can be developed using a standardized \ac{API} like Web Components. With this approach, no specific framework is needed for developing the application. \cite{book:2020:geers:background:micro-frontends:micro-frontends-in-action}

\subsubsection{Independently Deployable}\label{subsubsection:background:micro-frontend-independent-deployable}

The autonomy of micro-frontends offers the possibility for independent deployments. A sizeable monolithic frontend application is more complex to deploy, and there is no need for communication and coordination over multiple teams to deploy the application. Organizational dependencies negatively impact the time-to-market because development teams would have to wait for another team's release. \cite[12]{book:2020:geers:background:micro-frontends:micro-frontends-in-action}

\subsubsection{Small and Easy to Maintain}\label{subsubsection:background:micro-frontend-small-and-easy-to-maintain}

Because micro-frontends only cover a small domain of an application, the source code is smaller and easier to understand. A smaller codebase is especially helpful for understanding the inner workings of the software. Onboarding new team members is also more accessible because the codebase is smaller than monoliths.
Due to the easier understanding of the domain, the application can be easier rewritten with state-of-the-art technology if the old one becomes deprecated. \cite{book:2020:geers:background:micro-frontends:micro-frontends-in-action}

\subsubsection{Resilience}\label{subsubsection:background:micro-frontend-resilience}

Micro-frontends offer the possibility of building an application by composing multiple independent small applications into fully-fledged ones. Depending on the integration strategy, micro-frontends are usually combined at runtime. However, the network, especially for mobile devices, sometimes fails. A micro-frontend architecture provides better failure isolation. One micro-frontend crashing does not affect the other micro-frontends inside the application. Some parts of the application might not work, but other parts of the application are still usable. The application shell can react to a failure and tell users that the application is not working as expected and will be available soon. \cite[10-11]{article:2021:perltonen:background:micro-frontends:motivations-benefits-and-issues}

\subsection{Disadvantages}\label{subsection:background:micro-frontend-downsides}

Building micro-frontends comes with many advantages but also with some downsides. The following section describes some disadvantages of micro-frontends. The autonomy of having independent teams that build autonomous software comes with a price. A critical aspect of building software is eliminating redundancy in the code, and having multiple teams that build and run applications might introduce much redundancy. Moreover, if the \ac{BFF} pattern is used, the services to deploy increase even more, significantly increasing infrastructure complexity. Every team must set up its build process and a continuous integration pipeline. Duplicate \ac{CSS} and \ac{JS} code might be shipped to the browser. If multiple teams use a popular library and a critical security vulnerability is encountered, every team must update the dependency and deploy the application to fix the problem. It is essential to share knowledge between the teams to avoid fixing the same bugs repeatedly. The cost of having redundancies is lower than the negative impacts of having inter-team dependencies. The free choice of technology also comes with some disadvantages. It is hard for a developer to switch from one team to another or exchange their best practices for development. Like in distributed systems, keeping backward compatibility between the different micro-frontends takes much work. Different micro-frontends have different dependencies, versions, and interfaces.  \cite[17-18]{book:2020:geers:background:micro-frontends:micro-frontends-in-action} One of the main concerns is payload size, as independently-built JavaScript bundles can cause duplication of common dependencies, increasing the number of bytes sent over the network to end users. Additionally, maintaining consistency in user experience and visual design across different micro-frontends can take time, especially when developed by different teams or technologies. Maintaining a consistent look and feel across different components, like a Design System, can require additional effort and coordination. \cite{misc:2019:jackson:background:micro-frontends:disadvantages} Another problem addressed in this master thesis is the problem of over-fetching and over-requesting. Multiple micro-frontends might make exactly the same requests to the \ac{BFF}, leading to a higher server load. If a traditional \ac{REST} service is used, a micro-frontend might need to make more requests to fetch the desired data, while another might need precisely that data. 

% Another difficulty is how to slice micro-frontends. The micro-frontends should not depend on each other during runtime.

\input{chapters/background/micro-frontend/integration-strategies.tex}

\input{chapters/background/micro-frontend/communication-patterns.tex}

\input{chapters/background/micro-frontend/module-federation/module-federation.tex}

\input{chapters/background/micro-frontend/overfetching-overrequesting.tex}
