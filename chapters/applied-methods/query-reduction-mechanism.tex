\section{Built a mechanism that reduces the size of queries}\label{section:applied-methods:query-reduction}

After implementing the shared caching layer, the next step was to improve the performance of the micro-frontends by optimizing the use of the cache. The size of the network requests can be reduced by removing parts of a query that are already inside the cache. The theory behind removing fields from the query was already explained in section \ref{subsection:background:graphql:query-reduction}. The Apollo Client does not provide such a functionality out of the box, but the feature is requested in Apollo's Github Repository by many users. The section \ref{subsubsection:background:graphql:apollo-server-client:in-memory-cache-working} explains how the \texttt{InMemoryCache} cache of Apollo Client works in more detail. Briefly summarized the caching works with the name and the parameters of a GraphQL query. For example, if a query is executed against the GraphQL \ac{API}, the results of the query are cached. If the same query with the same fields is executed again with the same parameters, the results are fetched from the Apollo Client cache. If the query fetches an additional field, which is not inside the cache, the complete query is sent to the GraphQL \ac{API}. Only if the queried fields are completely identical, the data from the cache is used. Consequently, identical queries that fetch different fields are always fetched from the server.

\bigskip

\noindent Consider listing \ref{code:applied-methods:compare-allusers-user-query}, where the left query fetches all users, and the right query fetches a user by its id. Both queries fetch the same data type and the same fields, but they are fundamentally different queries. They have different names and different parameters. Both queries are sent to the GraphQL \ac{API}. The right query could be omitted if the user with the given id is fetched from the cache. If the left query is executed before the right query, the data to resolve the right query could be completely taken from the cache.

\ifshowListings
\begin{listing}[H]
\begin{minted}{typescript}
query allUsers {                        query user(id: ID!) {
  allUsers {                              user(id: \$id) {
    id                                      id
    username                                username
    email                                   email
    firstName                               firstName
    secondName                              secondName
  }                                       }
}                                      }
\end{minted}
\caption{Comparison between the \texttt{allUsers} and \texttt{User} query.}\label{code:applied-methods:compare-allusers-user-query}
\end{listing}
\fi

\noindent Apollo offers a solution to tackle this problem. The application might have a detail view and a list view that both query the same data like in listing \ref{code:applied-methods:compare-allusers-user-query}. The data for the \texttt{user} query might be already in the cache, but the Apollo Client does not know that. Therefore, the lookup of the cache can be configured, so that the Apollo Client knows where to look for the data. To better understand the cache redirection, a basic understanding of type policies is needed, which were described in more detail in section \ref{subsubsection:background:graphql:apollo-server-client:type-policies}.

\bigskip

\noindent To inform the Apollo Client where to look for the cached \texttt{User} object, a field policy \texttt{read} function must be written for the \texttt{user} query. Just like the \texttt{firstName} being a field of the \texttt{User} type is the \texttt{user}-query a field of the root query. This hierarchy resembles the structure of the GraphQL Schema, where the queries have to be defined inside the \texttt{Query} type. Listing \ref{code:applied-methods:query-reduction:graphql-schema} shows an excerpt from the GraphQL schema. All queries that can be executed by a client, are listed inside the \texttt{Query} type.

\ifshowListings
\begin{listing}[H]
\begin{minted}{typescript}
type Query {
  user(id: ID!): User
  allUsers(page: Int, perPage: Int): [User]
  ...
}

type User {
  id: ID!
  firstName: String!
  secondName: String!
  ...
}
\end{minted}
\caption{An excerpt from the GraphQL schema.}\label{code:applied-methods:query-reduction:graphql-schema}
\end{listing}
\fi


\noindent Listing \ref{code:applied-methods:query-reduction:user-cache-redirect} shows the \texttt{read} field policy for the \texttt{User}. Like in the GraphQL schema from listing \ref{code:applied-methods:query-reduction:graphql-schema}, the \texttt{user} query is a field of the root query. Therefore, every time the client queries the \texttt{user} query, the read function is executed. The \texttt{toReference} function is used to a cache reference for a \texttt{User} type. The reference is generated based on its \texttt{\_\_typename} and \texttt{id}, as explained in section \ref{subsubsection:background:graphql:apollo-server-client:data-normalization}. Apollo uses the result of \texttt{toReference} to look up the object in its cache and return it if it is present. If the object is not present in the cache, the query is sent to the GraphQL \ac{API}.

\ifshowListings
\begin{listing}[H]
\begin{minted}{typescript}
new ApolloClient({
  cache: new InMemoryCache({ typePolicies: { Query: { fields: {
    User: {
      read(_, { args, toReference }): {
        return toReference({ __typename: 'User', id: args.id });
      }
    }
  }}}})
});
\end{minted}
\caption{Writing a cache-redirect for the User-type.}\label{code:applied-methods:query-reduction:user-cache-redirect}
\end{listing}
\fi

\noindent Using cache redirects to reduce the amount of network requests works, but all of the query's requested fields must be already present in the cache. If the \texttt{user} query fetches any field that the \texttt{allUsers} query did not, Apollo Client considers the cache hit to be incomplete and the query is executed over the network. That a detail view and a list view are perfectly identical is very rare in applications. Therefore this approach can't be used to reduce the size of network requests effectively. And the approach is very verbose because a redirect has to be written for every data type. The approach does not scale, as the same type-policies would have to be written and registered for every micro-frontend.

\bigskip

\noindent The open source project \href{https://github.com/appmotion/apollo-augmented-hooks}{apollo-augmented-hooks} on GitHub provides drop-in replacements for Apollo's GraphQL query methods. It provides the functionality to remove fields from a query that are already in the cache. However, the big problem is that the project was developed specifically for React's Apollo Client. The dependencies were outdated and the latest release of the library was in 2021. To test the library an older version of Apollo Client was used. The dependency offered the functionality to remove fields that already exist in the cache from a previous GraphQL query. To use the functionality of the library inside the prototypical micro-frontend architecture, the Apollo-augmented-hooks dependency was forked. The first step was to update the dependencies to make it work with the latest version of Apollo Client. The problem with the old implementation is that it just supports React's Apollo Client with its hooks. The core functionality of the library was extracted and an adapter for React and Angular was written utilizing the functionality. The functions have the same \ac{API} as Apollo's original methods, therefore the migration is very easy. The functionality of the library was rewritten with \ac{TS} and some additional features were added, that utilize the cache even more. The implementation is detailed even further in the section \ref{subsection:applied-methods:query-reduction:how-does-the-library-work}.

\ifshowAppliedMethodsTestingQueryReduction
  \input{chapters/applied-methods/query-reduction/testing-query-reduction.tex}
\fi

\input{chapters/applied-methods/query-reduction/augmented-hooks.tex}

\input{chapters/applied-methods/query-reduction/example-reduction.tex}
