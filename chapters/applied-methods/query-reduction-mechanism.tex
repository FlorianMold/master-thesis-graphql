\section{Built a mechanism that reduces the size of queries}\label{section:applied-methods:query-reduction}

After implementing the shared caching layer, the next step was to improve the performance of the micro-frontends by optimizing the use of the cache. The size of the network requests can be reduced by removing parts of a query that are already inside the cache. The theory behind removing fields from the query was already explained in Section \ref{subsection:background:graphql:query-reduction}. The Apollo Client does not provide such a functionality out of the box, but many users request the feature in Apollo's Github Repository. Section \ref{subsubsection:background:graphql:apollo-server-client:in-memory-cache-working} explains how the \texttt{InMemoryCache} of Apollo Client works in more detail. Briefly summarized the caching works with the name and the parameters of a GraphQL query. For example, if a query is executed against the GraphQL \ac{API}, the results of the query are cached. If the same query with the same fields is executed again with the same parameters, the results are fetched from the Apollo Client cache. If the query fetches an additional field, not inside the cache, the complete query is sent to the GraphQL \ac{API}. Only if the queried fields are identical the cache data is used. Consequently, identical queries that fetch different fields are always fetched from the server.

\bigskip

\noindent Consider Listing \ref{code:applied-methods:compare-allusers-user-query}, where the left query fetches all users, and the query on the right fetches a user by its id. Both queries fetch the same data type and the same fields, but they are fundamentally different queries. They have different names and different parameters. Both queries are sent to the GraphQL \ac{API}. The query on the right could be omitted if the user with the given id is fetched from the cache. If the left query is executed before the query on the right, the data to resolve the query on the right could be taken entirely from the cache.

\ifshowListings
\begin{listing}[H]
\begin{minted}{typescript}
query allUsers {                        query user(id: ID!) {
  allUsers {                              user(id: id) {
    id                                      id
    username                                username
    email                                   email
    firstName                               firstName
    secondName                              secondName
  }                                       }
}                                      }
\end{minted}
\caption{Compare the fields between the \texttt{allUsers} and \texttt{User} query.}\label{code:applied-methods:compare-allusers-user-query}
\end{listing}
\fi

\noindent Apollo Client offers a solution to tackle this problem. The application might have a detail view and a list view that query the same data as in Listing \ref{code:applied-methods:compare-allusers-user-query}. The user query data might already be in the cache, but the Apollo Client does not know that. Therefore, the cache lookup can be configured so the Apollo Client knows where to look for the data. A basic understanding of type policies is needed to understand the cache redirection, described in more detail in Section \ref{subsubsection:background:graphql:apollo-server-client:type-policies}.

\bigskip

\noindent A field policy \texttt{read} function must be written for the user query to inform the Apollo Client where to look for the cached \texttt{User} object. Like the \texttt{firstName} being a \texttt{User} type field, the user query is a field of the root query. This hierarchy resembles the structure of the GraphQL Schema, where the queries have to be defined inside the \texttt{Query} type. Listing \ref{code:applied-methods:query-reduction:graphql-schema} shows an excerpt from the GraphQL schema. All queries that a client can execute are listed inside the \texttt{Query} type.

\ifshowListings
\begin{listing}[H]
\begin{minted}{typescript}
type Query {
  user(id: ID!): User
  allUsers(page: Int, perPage: Int): [User]
  ...
}

type User {
  id: ID!
  firstName: String!
  secondName: String!
  ...
}
\end{minted}
\caption{An excerpt of the prototypes GraphQL schema.}\label{code:applied-methods:query-reduction:graphql-schema}
\end{listing}
\fi


\noindent Listing \ref{code:applied-methods:query-reduction:user-cache-redirect} shows the \texttt{read} field policy for the \texttt{User}. Like in the GraphQL schema from Listing \ref{code:applied-methods:query-reduction:graphql-schema}, the user query is a field of the root query. Therefore, the read function is executed every time the client runs the user query. The \texttt{toReference} function is used to cache a reference for a \texttt{User} type. The reference is generated based on its \texttt{\_\_typename} and \texttt{id}, as explained in Section \ref{subsubsection:background:graphql:apollo-server-client:data-normalization}. Apollo Client uses the result of \texttt{toReference} to look up the object in its cache and return it if it is present. The query is sent to the GraphQL \ac{API} if the object is not in the cache.

\ifshowListings
\begin{listing}[H]
\begin{minted}{typescript}
new ApolloClient({
  cache: new InMemoryCache({ typePolicies: { Query: { fields: {
    User: {
      read(_, { args, toReference }): {
        return toReference({ __typename: 'User', id: args.id });
      }
    }
  }}}})
});
\end{minted}
\caption{A cache-redirect for the User-type.}\label{code:applied-methods:query-reduction:user-cache-redirect}
\end{listing}
\fi

\noindent Using cache redirects to reduce the amount of network requests works, but all of the query's requested fields must be already present in the cache. If the user query fetches any field that the \texttt{allUsers} query did not, Apollo Client considers the cache hit incomplete, and the query is executed over the network. That a detail view and a list view are perfectly identical is very rare in applications. Therefore, this approach cannot effectively reduce the size of network requests. Moreover, the approach is very verbose because a redirect has to be written for every data type. The approach does not scale; the same type-policies must be written and registered for every micro-frontend.

\bigskip

\noindent The open-source project \textbf{apollo-augmented-hooks}\footnote{\url{https://github.com/appmotion/apollo-augmented-hooks}} on GitHub provides drop-in replacements for Apollo's GraphQL query methods. It provides the functionality to remove fields from a query already in the cache. However, the big problem is that the project was developed specifically for React's Apollo Client. The dependencies were outdated, and the latest release of the library was in 2021. The library's functionality could only be tested with an old Apollo Client and React version. The dependency offered the functionality to remove fields in the cache from a previous GraphQL query. The \textbf{apollo-augmented-hooks} dependency was forked to use the functionality of the library inside the prototypical micro-frontend architecture. The first step was to update the dependencies to make it work with the latest version of Apollo Client. The problem with the old implementation is that it just supports React's Apollo Client with its hooks. The core functionality of the library was extracted, and an adapter for React and Angular was written utilizing the functionality. The functions have the same \ac{API} as Apollo Client's original methods, so migration to the new functions is straightforward. The library's functionality was rewritten with \ac{TS}, adding additional features that utilize the cache even more. The implementation is detailed further in Section \ref{subsection:applied-methods:query-reduction:how-does-the-library-work}.

\ifshowAppliedMethodsTestingQueryReduction
  \input{chapters/applied-methods/query-reduction/testing-query-reduction.tex}
\fi

\input{chapters/applied-methods/query-reduction/augmented-hooks.tex}

\input{chapters/applied-methods/query-reduction/example-reduction.tex}
