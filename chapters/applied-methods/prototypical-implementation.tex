\section{Implementing a prototypical micro-frontend architecture}\label{section:applied-methods:prototypical-implementation}

A prototypical micro-frontend architecture was implemented to evaluate the research questions. The architecture was developed to lay the groundwork for later use in a production environment. The micro-frontends are integrated using client-side integration, more precisely, run-time integration. The integration strategy was implemented with Webpack's Module Federation, which was described in more detail in Section \ref{subsection:background:micro-frontend:module-federation}. The central part of the implementation is written in Angular. One micro-frontend was implemented in React to showcase the technology agnosticism of the architecture. The prototype contains a single application shell that loads all other micro-frontends. The architecture is divided into nine widgets that display only simple data and four complex single-page applications. The four \acp{SPA} are Dashboard, Contact, Sales, and User.

\bigskip

\noindent Nx from the company Nwrl is used for managing multiple micro-frontends and libraries. The critical feature of Nx is the support for monorepos, which is the perfect match for micro-frontend applications. It offers support for almost any frontend framework and can be customized by plugins. Multiple related projects can be managed in a single workspace. Additionally, it helps that every project uses the same version of a dependency across the workspace. Besides, Nx offers helper functions for working with Module Federation in micro-frontends. \cite{misc:-:applied-methods:intro-to-nx}

\bigskip

\noindent A rough overview of the architecture is shown in Figure \ref{fig:applied-methods:prototype-micro-frontend-architecture}. It also shows a wireframe of how the structure of the application is looking. The icons inside the squares represent the \ac{JS} Framework used. Each widget is a separate application that exposes a remote module through Module Federation, which is consumed by the Dashboard micro-frontend.

\ifshowImages
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/applied-methods/prototypical-implementation/host-architecture.png}
    \caption{Architecture of the micro-frontend prototype.}\label{fig:applied-methods:prototype-micro-frontend-architecture}
\end{figure}
\fi

\noindent Each micro-frontend is deployed separately and is accessible by a unique \ac{URL}. The application shell is the entry point for the end user, and it consumes the Dashboard, Contact, Sales, and User application. The main functionality of the micro-frontends is implemented in modules. The remote modules of the applications can be easily exposed through Module Federation and consumed by the application shell and the standalone applications.

\bigskip

\noindent The Listing \ref{code:applied-methods:module-federation-config-expose} shows the configuration of the contact micro-frontend to expose its primary implementation through module federation in the form of the \texttt{entry.module}. The configuration of the other micro-frontends looks similar. The properties of the module-federation plugin were already discussed in the Section \ref{subsection:background:micro-frontend:module-federation}. All Angular- and Apollo- dependencies are specified to be shared across all micro-frontends. Sharing the dependencies ensures that all micro-frontends use the same version of the dependencies. In the Listing \ref{code:applied-methods:module-federation-config-expose}, the versions of the dependencies are written out. Inside the application, the versions are read from the \texttt{package.json} to ensure consistency. The versions are also important later to ensure the caching layer works correctly.

\ifshowListings
\begin{listing}[H]
    \begin{minted}{typescript}
module.exports = {
  name: 'contact',
  exposes: {
    './Module': 'apps/contact/src/app/remote-entry/entry.module.ts',
  },
  shared: [
    '@angular/core': {
      singleton: true, strictVersion: true, requiredVersion: '^15.1.1' 
    },
    ...
    'apollo-angular': { 
      singleton: true, strictVersion: true, requiredVersion: '^4.0.1' 
    },
    ...
  ]
};
    \end{minted}
    \caption{The Module Federation configuration to expose the contact's functionality.}\label{code:applied-methods:module-federation-config-expose}
\end{listing}
\fi

\noindent The application shell can be configured to consume the remote modules listed inside the remotes-object. The configuration to consume the four micro-frontends of the architecture can be seen in the Listing \ref{code:applied-methods:module-federation-config-consume}. With this configuration, the application-shell consumes the \texttt{entry.module} of the remote applications, which were exposed with the configuration from Listing \ref{code:applied-methods:module-federation-config-expose}. Like in the configuration of the remote modules, the application shell must also share all dependencies. Sharing the dependencies is needed so that the micro-frontends can load their runtime dependencies from the application shell and use the same dependency version.

\ifshowListings
\begin{listing}[H]
    \begin{minted}{typescript}
module.exports = {
  name: 'host',
  remotes: {
    contact: 'contact@http://localhost:4201/remoteEntry.js'
    sales: 'sales@http://localhost:4202/remoteEntry.js'
    dashboard: 'dashboard@http://localhost:4203/remoteEntry.js'
    user: 'user@http://localhost:4204/remoteEntry.js'
  },
  shared: {
    '@angular/core': {
      singleton: true, strictVersion: true, requiredVersion: '^15.1.1' 
    },
    ...
    'apollo-angular': { 
      singleton: true, strictVersion: true, requiredVersion: '^4.0.1' 
    },
    ...
  }
};
    \end{minted}
    \caption{The configuration of the application-shell to be able to consume micro-frontends.}\label{code:applied-methods:module-federation-config-consume}
\end{listing}
\fi

\noindent With the help of the Module Federation configuration, the application shell can load the remote modules. The remote modules are loaded asynchronously and can be referenced by the host application. The Listing \ref{code:applied-methods:angular-route-to-remote-module} shows the route configuration to the contact micro-frontend using the Angular router. Nx offers helper methods like \texttt{loadRemoteModule} for Module Federation to load remote modules into the routes of the application shell. The prototype of the application shell shows one micro-frontend per route.

\ifshowListings
\begin{listing}[H]
  \begin{minted}{typescript}
const routes: Routes = [
  {
    path: 'contact',
    loadChildren: () => loadRemoteModule('contact', './Module')
      .then((m) => m.ContactRemoteEntryModule),
  },
  ...
]
  \end{minted}
  \caption{An Angular route to the contact application.}\label{code:applied-methods:angular-route-to-remote-module}
\end{listing}
\fi

\ifshowAppliedMethodsCustomNginxConfSection
  \input{chapters/applied-methods/prototypical-implementation/nginx-problems}
\fi

\input{chapters/applied-methods/prototypical-implementation/integrating-react}

\input{chapters/applied-methods/prototypical-implementation/backend-for-frontend-pattern}

\ifshowAppliedMethodsLoadRemoteSettingsSection
  \input{chapters/applied-methods/prototypical-implementation/load-remote-settings}
\fi

\ifshowAppliedMethodsSecondaryEntrypoints
  \input{chapters/applied-methods/prototypical-implementation/sharing-secondary-entrypoints}
\fi